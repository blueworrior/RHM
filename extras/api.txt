Routes(api):
admin.js:
const express = require('express');
const router = express.Router();

const auth = require('../middleware/authMiddleware');
const role = require('../middleware/roleMiddleware');
const superAdminOnly = require('../middleware/superAdminOnly');

const adminController = require('../controllers/adminController');

// Admin
router.post('/admins', auth, role(['admin']), superAdminOnly, adminController.createAdmin);


// Department
router.post('/departments', auth, role(['admin']), adminController.createDepartment);
router.get('/departments', auth, role(['admin']), adminController.getDepartments);

// Coordinator
router.post('/coordinators', auth, role(['admin']), adminController.createCoordinator);
router.get('/coordinators', auth, role(['admin']), adminController.getCoordinator);

// Supervisor
router.post('/supervisors', auth, role(['admin']), adminController.createSupervisor);
router.get('/supervisors', auth, role(['admin']), adminController.getSupervisor);

// Students
router.get('/students', auth, role(['admin']), adminController.getAllStudents);

// Examiner
router.post('/examiners', auth, role(['admin']), adminController.createExaminer);
router.get('/examiners', auth, role(['admin']), adminController.getExaminer);

module.exports = router;

coordinator.js:
const express = require('express');
const router = express.Router();

const auth = require('../middleware/authMiddleware');
const role = require('../middleware/roleMiddleware');

const coordinatorController = require('../controllers/coordinatorController');

// STUDENTS
// -> 1. create sttudent
router.post('/students', auth, role(['coordinator']), coordinatorController.createStudent);
// -> 2. list students of my department
router.get('/my-students', auth, role(['coordinator']), coordinatorController.getMyDepartmentStudents);
// -> 3. list students without supervisor
router.get('/unassigned-students', auth, role(['coordinator']), coordinatorController.getUnassignedStudents);
// -> 4 . update student
router.put('/students', auth, role(['coordinator']), coordinatorController.updateStudent);
// -> 5. delete student
router.delete('/students/:student_id', auth, role(['coordinator']), coordinatorController.deleteStudent);

// -> 6. list supervisors of my department
router.get('/my-supervisors', auth, role(['coordinator']), coordinatorController.getMyDepartmentSupervisors);
// -> 7. assign supervisor to student
router.put('/assign-supervisor', auth, role(['coordinator']), coordinatorController.assignSupervisor);
// -> 8. remove supervisor
router.put('/remove-supervisor', auth, role(['coordinator']), coordinatorController.removeSupervisor);

// -> 9. PUBLICATION (list all my department student )
router.get('/publications', auth, role(['coordinator']), coordinatorController.getDepartmentPublications);

// -> 10 ASSIGN EXAMINER
router.post('/assign-examiner', auth, role(['coordinator']), coordinatorController.assignExaminer);

// -> 11 GET thesis with evaluations
router.get('/thesis/evaluated', auth, role(['coordinator']), coordinatorController.getEvaluatedTheses);
// -> 12 Get Thesis Evaluations
router.get('/thesis/:id/evaluations', auth, role(['coordinator']), coordinatorController.getThesisEvaluations);
// -> 13 Get Ready thesis
router.get('/thesis/ready', auth, role(['coordinator']), coordinatorController.getReadyThesis); 
// -> 14 Decide Thesis
router.put('/thesis/:id/final-decision', auth, role(['coordinator']), coordinatorController.finalizeThesis);

module.exports = router;

supervisor.js:
const express = require('express');
const router = express.Router();

const auth = require('../middleware/authMiddleware');
const role = require('../middleware/roleMiddleware');

const supervisorProposal = require('../controllers/supervisorController');

// Proposals
// -> 1. List Student proposal
router.get('/proposals', auth, role(['supervisor']), supervisorProposal.getMyStudentProposals);
// -> 2. Appprove / Reject Proposal
router.put('/proposals/:id/decision', auth, role(['supervisor']), supervisorProposal.decideProposal);


// PROGRESS REPORTS
// -> 1. List my student progress REports
router.get('/progress-reports', auth, role(['supervisor']), supervisorProposal.getStudentProgressReports);
// -> 2. Approve/ Reject Progress Report
router.put('/progress-reports/:id/decision', auth, role(['supervisor']), supervisorProposal.decideProgressReport);
//PUblication (list my students publication)
router.get('/publications', auth, role(['supervisor']), supervisorProposal.getMyStudentPublications);


// Thesis
// -> 1. List my student Thesis
router.get('/thesis', auth, role(['supervisor']), supervisorProposal.getMyStudentThesis);
// -> 2. Approve/ Reject thesis
router.put('/thesis/:id/decision', auth, role(['supervisor']), supervisorProposal.decideThesis);

module.exports = router;

student.js:
const express = require('express');
const router = express.Router();

const auth = require('../middleware/authMiddleware');
const role = require('../middleware/roleMiddleware');
const uploadProposal = require('../middleware/uploadProposal');
const uploadProgress = require('../middleware/uploadProgress');
const uploadThesis = require('../middleware/uploadThesis');


const studentController = require('../controllers/studentController');


// PROPOSALS
// -> 1.Submit proposal
router.post(
    '/proposals', 
    auth, 
    role(['student']), 
    uploadProposal.single('proposal_file'), 
    studentController.submitProposal
);
// -> 2. List propsal
router.get('/proposals', auth, role(['student']), studentController.getMyProposals);
// -> 3. view proposal status + remarks
router.get('/proposals/status', auth, role(['student']), studentController.getMyProposalStatus);


// PROGRESS REPORTS
// -> 1. Submit progress report
router.post(
    '/progress-reports',
    auth,
    role(['student']),
    uploadProgress.single('report_file'),
    studentController.submitProgressReport
);
// -> 2. List Progress Report
router.get('/progress-reports', auth, role(['student']), studentController.getMyProgressReport);


// Publication
// -> 1. Add publication
router.post('/publications', auth, role(['student']), studentController.addPublication);
// -> 2. List publication
router.get('/publications', auth, role(['student']), studentController.getMypublication);


// THESIS
// -> 1. Add thesis
router.post('/thesis', auth, role(['student']), uploadThesis.single('thesis_file') , studentController.submitThesis);
// -> 2. List thesis
router.get('/thesis', auth, role(['student']), studentController.getMyThesis);
// -> 3. Resubmit Thesis
router.put('/thesis/resubmit', auth, role(['student']), uploadThesis.single('thesis_file'), studentController.resubmitThesis);

module.exports = router;

examiner.js:
const express = require('express');
const router = express.Router();
const examinerController = require('../controllers/examinerController');
const auth = require('../middleware/authMiddleware');
const role = require('../middleware/roleMiddleware');

// 1. see assign thesis
router.get('/thesis', auth, role('examiner'), examinerController.getMyAssignedTheses);
// 2. Evaluate Thesis
router.post('/thesis/:id/evaluate', auth, role('examiner'), examinerController.evaluateThesis);

module.exports = router;


auth.js:
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

// LOGIN
router.post('/login', authController.login);

module.exports = router;




API CODE(Controllers):
...this is adminControllers.js:
const db = require('../config/db');
const bcrypt = require('bcryptjs');


/* =====================================================
   âœ… CREATE ADMIN (SUPER ADMIN ONLY)
===================================================== */

exports.createAdmin = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        // ðŸ” only super admin allowed
        if (!req.user?.is_super_admin) {
            return res.status(403).json({
                message: "Only Super Admin can create admins"
            });
        }

        const { first_name, last_name, email, password } = req.body;

        if (!first_name || !last_name || !email || !password) {
            return res.status(400).json({ message: "All fields required" });
        }

        await connection.beginTransaction();

        // check email
        const [existing] = await connection.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existing.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Email already exists" });
        }

        const hashPass = await bcrypt.hash(password, 10);

        const [result] = await connection.query(`
            INSERT INTO users
            (role_id, first_name, last_name, email, password, is_super_admin)
            VALUES (1, ?, ?, ?, ?, false)
        `, [first_name, last_name, email, hashPass]);

        await connection.commit();

        res.status(201).json({
            message: "Admin created successfully",
            user_id: result.insertId
        });

    } catch (err) {

        await connection.rollback();
        console.error(err);

        res.status(500).json({
            message: "Server Error"
        });

    } finally {
        connection.release();
    }
};



/* =====================================================
   DEPARTMENTS
===================================================== */

exports.createDepartment = async (req, res) => {

    try {

        const { name } = req.body;

        if (!name) {
            return res.status(400).json({
                message: 'Department name is required'
            });
        }

        const [existing] = await db.promise().query(
            'SELECT id FROM departments WHERE name = ?',
            [name]
        );

        if (existing.length > 0) {
            return res.status(409).json({
                message: "Department already exists"
            });
        }

        const [result] = await db.promise().query(
            'INSERT INTO departments (name) VALUES (?)',
            [name]
        );

        res.status(201).json({
            message: "Department Created Successfully",
            department_id: result.insertId
        });

    } catch (err) {

        console.error(err);
        res.status(500).json({ message: "Server Error" });

    }
};



exports.getDepartments = async (req, res) => {

    try {

        const [rows] = await db.promise().query(
            `SELECT id, name FROM departments ORDER BY name`
        );

        res.json(rows);

    } catch (err) {

        res.status(500).json({ message: "Server Error" });

    }
};



/* =====================================================
   CREATE COORDINATOR (TRANSACTION)
===================================================== */

exports.createCoordinator = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const { first_name, last_name, email, password, dept_id } = req.body;

        if (!first_name || !last_name || !email || !password || !dept_id) {
            return res.status(400).json({ message: "All fields are required" });
        }

        await connection.beginTransaction();

        const [existing] = await connection.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existing.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Email already exists" });
        }

        const hashPass = await bcrypt.hash(password, 10);

        const [user] = await connection.query(`
            INSERT INTO users
            (role_id, first_name, last_name, email, password)
            VALUES (2, ?, ?, ?, ?)
        `, [first_name, last_name, email, hashPass]);

        await connection.query(`
            INSERT INTO coordinators (user_id, dept_id)
            VALUES (?, ?)
        `, [user.insertId, dept_id]);

        await connection.commit();

        res.status(201).json({
            message: "Coordinator Created Successfully",
            user_id: user.insertId
        });

    } catch (err) {

        await connection.rollback();
        console.error(err);

        res.status(500).json({ message: "Server Error" });

    } finally {
        connection.release();
    }
};



exports.getCoordinator = async (req, res) => {

    try {

        const [rows] = await db.promise().query(`
            SELECT 
                u.id AS user_id,
                u.first_name,
                u.last_name,
                u.email,
                d.name AS department
            FROM users u
            JOIN coordinators c ON u.id = c.user_id
            JOIN departments d ON c.dept_id = d.id
            ORDER BY u.first_name
        `);

        res.json(rows);

    } catch {

        res.status(500).json({ message: "Server Error" });
    }
};



/* =====================================================
   CREATE SUPERVISOR (TRANSACTION)
===================================================== */

exports.createSupervisor = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const {
            first_name,
            last_name,
            email,
            password,
            dept_id,
            designation,
            expertise
        } = req.body;

        if (!first_name || !last_name || !email || !password || !dept_id || !designation || !expertise) {
            return res.status(400).json({ message: "All fields required" });
        }

        await connection.beginTransaction();

        const [existing] = await connection.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existing.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Email already exists" });
        }

        const hashPass = await bcrypt.hash(password, 10);

        const [user] = await connection.query(`
            INSERT INTO users
            (role_id, first_name, last_name, email, password)
            VALUES (3, ?, ?, ?, ?)
        `, [first_name, last_name, email, hashPass]);

        await connection.query(`
            INSERT INTO supervisors
            (user_id, dept_id, designation, expertise)
            VALUES (?, ?, ?, ?)
        `, [user.insertId, dept_id, designation, expertise]);

        await connection.commit();

        res.status(201).json({
            message: "Supervisor created successfully",
            user_id: user.insertId
        });

    } catch (err) {

        await connection.rollback();
        console.error(err);

        res.status(500).json({ message: "Server Error" });

    } finally {
        connection.release();
    }
};



exports.getSupervisor = async (req, res) => {

    try {

        const [rows] = await db.promise().query(`
            SELECT
                s.id AS supervisor_id,
                u.first_name,
                u.last_name,
                u.email,
                d.name AS department
            FROM users u
            JOIN supervisors s ON s.user_id = u.id
            JOIN departments d ON s.dept_id = d.id
            ORDER BY u.first_name
        `);

        res.json(rows);

    } catch {

        res.status(500).json({ message: "Server Error" });
    }
};



/* =====================================================
   STUDENTS LIST
===================================================== */

exports.getAllStudents = async (req, res) => {

    try {

        const [rows] = await db.promise().query(`
            SELECT 
                students.id,
                students.registration_no,
                students.research_area,
                students.enrollment_date,
                users.first_name,
                users.last_name,
                users.email,
                departments.name AS department_name,
                CONCAT(supUsers.first_name, ' ', supUsers.last_name) AS supervisor
            FROM students
            JOIN users ON students.user_id = users.id
            JOIN departments ON students.dept_id = departments.id
            LEFT JOIN supervisors ON students.supervisor_id = supervisors.id
            LEFT JOIN users AS supUsers ON supervisors.user_id = supUsers.id
        `);

        res.json(rows);

    } catch {

        res.status(500).json({ message: "Server Error" });
    }
};



/* =====================================================
   CREATE EXAMINER (TRANSACTION)
===================================================== */

exports.createExaminer = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const { first_name, last_name, email, password, dept_id, designation } = req.body;

        if (!first_name || !last_name || !email || !password || !dept_id || !designation) {
            return res.status(400).json({ message: "All fields required" });
        }

        await connection.beginTransaction();

        const [existing] = await connection.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (existing.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Email already exists" });
        }

        const hashPass = await bcrypt.hash(password, 10);

        const [user] = await connection.query(`
            INSERT INTO users
            (role_id, first_name, last_name, email, password)
            VALUES (5, ?, ?, ?, ?)
        `, [first_name, last_name, email, hashPass]);

        await connection.query(`
            INSERT INTO examiners (user_id, dept_id, designation)
            VALUES (?, ?, ?)
        `, [user.insertId, dept_id, designation]);

        await connection.commit();

        res.status(201).json({
            message: "Examiner Created successfully",
            user_id: user.insertId
        });

    } catch (err) {

        await connection.rollback();
        console.error(err);

        res.status(500).json({ message: "Server Error" });

    } finally {
        connection.release();
    }
};



exports.getExaminer = async (req, res) => {

    try {

        const [rows] = await db.promise().query(`
            SELECT
                u.id AS user_id,
                u.first_name,
                u.last_name,
                d.name AS department
            FROM users u
            JOIN examiners e ON u.id = e.user_id
            JOIN departments d ON e.dept_id = d.id
        `);

        res.json(rows);

    } catch {

        res.status(500).json({ message: "Server Error" });
    }
};




this is authController.js:
const db = require('../config/db');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

exports.login = async (req, res) => {

    try {

        const { email, password } = req.body;

        if (!email || !password) {
            return res.status(400).json({
                message: "Email and password required"
            });
        }

        const sql = `
            SELECT 
                users.id,
                users.first_name,
                users.last_name,
                users.password,
                users.is_super_admin,
                roles.name AS role
            FROM users
            JOIN roles ON users.role_id = roles.id
            WHERE users.email = ?
        `;

        const [results] = await db.promise().query(sql, [email]);

        if (results.length === 0) {
            return res.status(401).json({
                message: 'Invalid email or password'
            });
        }

        const user = results[0];

        const isMatch = await bcrypt.compare(password, user.password);

        if (!isMatch) {
            return res.status(401).json({
                message: 'Invalid email or password'
            });
        }

        // âœ… TOKEN WITH SUPER ADMIN
        const token = jwt.sign(
            {
                id: user.id,
                role: user.role,
                is_super_admin: !!user.is_super_admin   // converts 1 â†’ true
            },
            process.env.JWT_SECRET,
            { expiresIn: '1d' }
        );

        res.json({
            token,
            user: {
                id: user.id,
                first_name: user.first_name,
                last_name: user.last_name,
                role: user.role,
                is_super_admin: !!user.is_super_admin
            }
        });

    } catch (err) {

        console.error(err);

        res.status(500).json({
            message: "Server Error"
        });
    }
};



this is coordinateController.js:
const db = require('../config/db');
const bcrypt = require('bcryptjs');

//////////////////////////////////////////////////////////////
// CREATE STUDENT (TRANSACTION SAFE)
//////////////////////////////////////////////////////////////

exports.createStudent = async (req, res) => {

    const conn = await db.promise().getConnection();

    try {

        const {
            first_name,
            last_name,
            email,
            password,
            dept_id,
            registration_no,
            research_area,
            enrollment_date
        } = req.body;

        if (!first_name || !last_name || !email || !password || !dept_id || !registration_no || !research_area || !enrollment_date) {
            return res.status(400).json({ message: "All fields are required" });
        }

        await conn.beginTransaction();

        // email unique check
        const [emailCheck] = await conn.query(
            'SELECT id FROM users WHERE email = ?',
            [email]
        );

        if (emailCheck.length > 0) {
            await conn.rollback();
            return res.status(409).json({ message: "Email already exists" });
        }

        // registration check
        const [regCheck] = await conn.query(
            'SELECT id FROM students WHERE registration_no = ?',
            [registration_no]
        );

        if (regCheck.length > 0) {
            await conn.rollback();
            return res.status(409).json({ message: "Registration number already exists" });
        }

        const hashedPass = await bcrypt.hash(password, 10);

        // role_id = 4 (student)
        const [userResult] = await conn.query(
            `INSERT INTO users (role_id, first_name, last_name, email, password)
             VALUES (?, ?, ?, ?, ?)`,
            [4, first_name, last_name, email, hashedPass]
        );

        const user_id = userResult.insertId;

        await conn.query(
            `INSERT INTO students
            (user_id, dept_id, registration_no, research_area, enrollment_date)
            VALUES (?, ?, ?, ?, ?)`,
            [user_id, dept_id, registration_no, research_area, enrollment_date]
        );

        await conn.commit();

        res.status(201).json({
            message: "Student added successfully",
            user_id
        });

    } catch (err) {

        await conn.rollback();

        if (err.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: "Duplicate entry detected" });
        }

        console.error(err);
        res.status(500).json({ message: "Server Error" });

    } finally {
        conn.release();
    }
};

//////////////////////////////////////////////////////////////
// GET DEPARTMENt STUDENTS
//////////////////////////////////////////////////////////////
exports.getMyDepartmentStudents = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [rows] = await connection.query(`
            SELECT 
                st.id,
                st.registration_no,
                st.research_area,
                st.enrollment_date,

                u.first_name,
                u.last_name,
                u.email,

                CONCAT(supU.first_name,' ',supU.last_name) AS supervisor

            FROM students st
            JOIN users u ON st.user_id = u.id

            LEFT JOIN supervisors sup ON st.supervisor_id = sup.id
            LEFT JOIN users supU ON sup.user_id = supU.id

            WHERE st.dept_id = ?
            ORDER BY u.first_name
        `, [coord.dept_id]);

        res.json(rows);

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

//////////////////////////////////////////////////////////////
// GET UNASSIGNED STUDENTS
//////////////////////////////////////////////////////////////
exports.getUnassignedStudents = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [rows] = await connection.query(`
            SELECT
                st.id AS student_id,
                u.first_name,
                u.last_name,
                u.email,
                st.registration_no,
                st.research_area,
                st.enrollment_date
            FROM students st
            JOIN users u ON st.user_id = u.id
            WHERE st.dept_id = ?
            AND st.supervisor_id IS NULL
            ORDER BY u.first_name
        `, [coord.dept_id]);

        res.json(rows);

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// UPDATE STUDENTS
//////////////////////////////////////////////////////////////
exports.updateStudent = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const { student_id, research_area, registration_no } = req.body;
        const user_id = req.user.id;

        if (!student_id)
            return res.status(400).json({ message: "Student id required" });

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [result] = await connection.query(`
            UPDATE students
            SET research_area = ?, registration_no = ?
            WHERE id = ?
            AND dept_id = ?
        `, [research_area, registration_no, student_id, coord.dept_id]);

        if (result.affectedRows === 0)
            return res.status(403).json({ message: "You cannot update this student" });

        res.json({ message: "Student updated successfully" });

    } catch (err) {

        if (err.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: "Registration number already exists" });
        }

        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// DELETE STUDENT (TRANSACTION)
//////////////////////////////////////////////////////////////

exports.deleteStudent = async (req, res) => {

    const conn = await db.promise().getConnection();

    try {

        const { student_id } = req.params;
        const coordinator_id = req.user.id;

        await conn.beginTransaction();

        const [[coord]] = await conn.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [coordinator_id]
        );

        if (!coord) {
            await conn.rollback();
            return res.status(403).json({ message: "Not a coordinator" });
        }

        const [[student]] = await conn.query(
            `SELECT user_id FROM students
             WHERE id = ? AND dept_id = ?`,
            [student_id, coord.dept_id]
        );

        if (!student) {
            await conn.rollback();
            return res.status(403).json({ message: "You cannot delete this student" });
        }

        await conn.query(
            'DELETE FROM users WHERE id = ?',
            [student.user_id]
        );

        await conn.commit();

        res.json({ message: "Student deleted successfully" });

    } catch (err) {

        await conn.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });

    } finally {
        conn.release();
    }
};


//////////////////////////////////////////////////////////////
// GET DEPARTMENT SUPERVISOR
//////////////////////////////////////////////////////////////
exports.getMyDepartmentSupervisors = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [rows] = await connection.query(`
            SELECT
                s.id AS supervisor_id,
                u.first_name,
                u.last_name,
                s.designation,
                s.expertise
            FROM supervisors s
            JOIN users u ON s.user_id = u.id
            WHERE s.dept_id = ?
            ORDER BY u.first_name
        `, [coord.dept_id]);

        res.json(rows);

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};


//////////////////////////////////////////////////////////////
// ASSIGN SUPERVISOR (DEPARTMENT SAFE)
//////////////////////////////////////////////////////////////

exports.assignSupervisor = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const { student_id, supervisor_id } = req.body;
        const coordinator_id = req.user.id;

        if (!student_id || !supervisor_id) {
            return res.status(400).json({ message: "Student and Supervisor id required" });
        }

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [coordinator_id]
        );

        if (!coord) {
            return res.status(403).json({ message: "Not a coordinator" });
        }

        const dept_id = coord.dept_id;

        const [[student]] = await connection.query(
            'SELECT id FROM students WHERE id = ? AND dept_id = ?',
            [student_id, dept_id]
        );

        if (!student) {
            return res.status(403).json({ message: "Student not in your department" });
        }

        const [[supervisor]] = await connection.query(
            'SELECT id FROM supervisors WHERE id = ? AND dept_id = ?',
            [supervisor_id, dept_id]
        );

        if (!supervisor) {
            return res.status(403).json({ message: "Supervisor not in your department" });
        }

        await connection.query(
            `UPDATE students
             SET supervisor_id = ?
             WHERE id = ?`,
            [supervisor_id, student_id]
        );

        res.json({ message: "Supervisor assigned successfully" });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// REMOVE SUPERVISOR
//////////////////////////////////////////////////////////////

exports.removeSupervisor = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const { student_id } = req.body;

        if (!student_id) {
            return res.status(400).json({ message: "Student id required" });
        }

        const [notAssign] = await connection.query(
            `SELECT *
             FROM students
             WHERE id = ?`,
            [student_id]
        );

        if (notAssign.length === 0) {
            return res.status(404).json({ message: "Student not found" });
        }
        if (notAssign[0].supervisor_id === null) {
            return res.status(400).json({ message: "Student already has no supervisor" });
        }

        await connection.query(
            `UPDATE students
             SET supervisor_id = NULL
             WHERE id = ?`,
            [student_id]
        );


        res.json({ message: "Supervisor removed successfully" });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// GET DEPARTMENT PUBLICATIONS
//////////////////////////////////////////////////////////////
exports.getDepartmentPublications = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const user_id = req.user.id;

        // 1. Get coordinator dept
        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord) return res.status(403).json({ message: "Not a coordinator" });

        // 2. Get publications
        const [rows] = await connection.query(`
            SELECT
                p.id AS publication_id,
                p.title,
                p.journal_name,
                p.year,
                p.type,
                s.registration_no,
                CONCAT(u.first_name, ' ', u.last_name) AS student_name
            FROM publications p
            JOIN students s ON p.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.dept_id = ?
            ORDER BY p.year DESC
        `, [coord.dept_id]);

        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

//////////////////////////////////////////////////////////////
// ASSIGN EXAMINER (FULL TRANSACTION)
//////////////////////////////////////////////////////////////
exports.assignExaminer = async (req, res) => {

    const conn = await db.promise().getConnection();

    try {

        const coordinator_id = req.user.id;
        const { thesis_id, examiner_id } = req.body;

        await conn.beginTransaction();

        const [[coord]] = await conn.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [coordinator_id]
        );

        if (!coord) {
            await conn.rollback();
            return res.status(403).json({ message: "Not a coordinator" });
        }

        const dept_id = coord.dept_id;

        const [thesis] = await conn.query(
            `SELECT t.id
             FROM thesis t
             JOIN students s ON t.student_id = s.id
             WHERE t.id = ?
             AND s.dept_id = ?
             AND t.is_locked = FALSE`,
            [thesis_id, dept_id]
        );

        if (!thesis.length) {
            await conn.rollback();
            return res.status(409).json({ message: "Invalid thesis" });
        }

        const [[examiner]] = await conn.query(
            `SELECT id FROM examiners
             WHERE id = ? AND dept_id = ?`,
            [examiner_id, dept_id]
        );

        if (!examiner) {
            await conn.rollback();
            return res.status(409).json({ message: "Examiner not in department" });
        }

        const [[count]] = await conn.query(
            `SELECT COUNT(*) AS total
             FROM examiner_assignments
             WHERE thesis_id = ?`,
            [thesis_id]
        );

        if (count.total >= 3) {
            await conn.rollback();
            return res.status(409).json({ message: "Max 3 examiners allowed" });
        }
        const [[duplicate]] = await conn.query(
            `SELECT id 
             FROM examiner_assignments
             WHERE thesis_id = ? AND examiner_id = ?`,
            [thesis_id, examiner_id]
        );

        if (duplicate) {
            await conn.rollback();
            return res.status(409).json({ message: "Same examiner already assigned to this thesis" });
        }

        await conn.query(
            `INSERT INTO examiner_assignments (thesis_id, examiner_id)
             VALUES (?, ?)`,
            [thesis_id, examiner_id]
        );

        await conn.query(
            `UPDATE thesis
             SET status = 'Under_Examination'
             WHERE id = ?`,
            [thesis_id]
        );

        await conn.commit();

        res.json({ message: "Examiner assigned successfully" });

    } catch (err) {

        await conn.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });

    } finally {
        conn.release();
    }
};

//////////////////////////////////////////////////////////////
// GET EVALUATED THESIS
//////////////////////////////////////////////////////////////
exports.getEvaluatedTheses = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [rows] = await connection.query(`
            SELECT 
                t.id AS thesis_id,
                t.title,
                t.status,
                t.version,
                t.submitted_at,

                s.registration_no,
                CONCAT(u.first_name,' ',u.last_name) AS student_name,

                COUNT(DISTINCT eg.examiner_id) AS total_evaluations

            FROM thesis t
            JOIN students s ON t.student_id = s.id
            JOIN users u ON s.user_id = u.id
            JOIN examiner_grades eg
                ON eg.thesis_id = t.id
                AND eg.thesis_version = t.version

            WHERE s.dept_id = ?
            GROUP BY t.id
            ORDER BY t.submitted_at DESC
        `, [coord.dept_id]);

        res.json({
            total: rows.length,
            theses: rows
        });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// GET THESIS EVALUATIONS
//////////////////////////////////////////////////////////////
exports.getThesisEvaluations = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;
        const thesis_id = req.params.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not a coordinator" });

        const [evals] = await connection.query(`
            SELECT
                eg.thesis_id,
                t.version,
                eg.grade,
                eg.remarks,
                eg.created_at,
                CONCAT(u.first_name,' ',u.last_name) AS examiner_name
            FROM examiner_grades eg
            JOIN thesis t ON eg.thesis_id = t.id
            JOIN students s ON t.student_id = s.id
            JOIN examiners e ON eg.examiner_id = e.id
            JOIN users u ON e.user_id = u.id
            WHERE s.dept_id = ?
            AND eg.thesis_version = t.version
            AND eg.thesis_id = ?
            ORDER BY eg.created_at DESC
        `, [coord.dept_id, thesis_id]);

        res.json({
            total: evals.length,
            evaluations: evals
        });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// GET READY THESIS
//////////////////////////////////////////////////////////////
exports.getReadyThesis = async (req, res) => {

    const connection = await db.promise().getConnection();

    try {

        const user_id = req.user.id;

        const [[coord]] = await connection.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [user_id]
        );

        if (!coord)
            return res.status(403).json({ message: "Not coordinator" });

        const [rows] = await connection.query(`
            SELECT 
                t.id,
                t.title,
                t.version,
                u.first_name,
                u.last_name,
                s.registration_no
            FROM thesis t
            JOIN students s ON t.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.dept_id = ?
            AND t.ready_for_final = TRUE
            AND t.is_locked = FALSE
        `, [coord.dept_id]);

        res.json(rows);

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    }
};

//////////////////////////////////////////////////////////////
// FINALIZE THESIS (VERY IMPORTANT TRANSACTION)
//////////////////////////////////////////////////////////////

exports.finalizeThesis = async (req, res) => {

    const conn = await db.promise().getConnection();

    try {

        const coordinator_id = req.user.id;
        const thesis_id = req.params.id;
        const { status, remarks } = req.body;

        if (!['Approved', 'Rejected'].includes(status)) {
            return res.status(400).json({ message: "Invalid status" });
        }

        await conn.beginTransaction();

        const [[coord]] = await conn.query(
            'SELECT dept_id FROM coordinators WHERE user_id = ?',
            [coordinator_id]
        );

        if (!coord) {
            await conn.rollback();
            return res.status(403).json({ message: "Not a coordinator" });
        }

        const [[thesis]] = await conn.query(
            `SELECT t.version
             FROM thesis t
             JOIN students s ON t.student_id = s.id
             WHERE t.id = ?
             AND s.dept_id = ?
             AND t.ready_for_final = TRUE`,
            [thesis_id, coord.dept_id]
        );

        if (!thesis) {
            await conn.rollback();
            return res.status(403).json({ message: "Invalid thesis state" });
        }

        await conn.query(
            `UPDATE thesis
             SET status = ?, is_locked = ?
             WHERE id = ?`,
            [
                status === 'Approved' ? 'Approved_Final' : status,
                status === 'Approved',
                thesis_id
            ]
        );

        await conn.query(
            `INSERT INTO approvals
            (reference_type, reference_id, approval_role, approved_by, status, remarks, thesis_version)
            VALUES ('thesis', ?, 'Coordinator', ?, ?, ?, ?)`,
            [thesis_id, coordinator_id, status, remarks || null, thesis.version]
        );

        await conn.query(
            `UPDATE examiner_assignments
             SET is_active = FALSE
             WHERE thesis_id = ?`,
            [thesis_id]
        );

        await conn.commit();

        res.json({ message: `Thesis ${status} successfully` });

    } catch (err) {

        await conn.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });

    } finally {
        conn.release();
    }
};




this is examinerController.js:
const db = require('../config/db');

// SQL to get examiner id
const examinersql = `SELECT id FROM examiners WHERE user_id = ?`;

// 1. List assigned theses
exports.getMyAssignedTheses = async (req, res) => {
    try {
        const user_id = req.user.id;

        // get examiner id
        const [examinerResult] = await db.promise().query(examinersql, [user_id]);
        
        if (examinerResult.length === 0) {
            return res.status(403).json({ message: "Not an examiner" });
        }

        const examiner_id = examinerResult[0].id;

        const sql = `
            SELECT
                t.id AS thesis_id,
                t.title,
                t.file_path,
                t.status,
                t.submitted_at,
                s.registration_no,
                CONCAT(u.first_name, ' ', u.last_name) AS student_name
            FROM examiner_assignments ea
            JOIN thesis t ON ea.thesis_id = t.id
            JOIN students s ON t.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE ea.examiner_id = ?
            ORDER BY t.status
        `;

        const [rows] = await db.promise().query(sql, [examiner_id]);
        res.json(rows);

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error fetching assigned theses" });
    }
};


// 2. Evaluate Thesis (VERSION SAFE & TRANSACTIONAL)
exports.evaluateThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    
    try {
        const user_id = req.user.id;
        const { grade, remarks } = req.body;
        const thesis_id = req.params.id;

        if (!thesis_id || !grade) {
            return res.status(400).json({ message: "Missing fields" });
        }

        // 1. Get examiner id
        const [examinerResult] = await connection.query(examinersql, [user_id]);
        if (examinerResult.length === 0) {
            return res.status(403).json({ message: "Not an examiner" });
        }
        const examiner_id = examinerResult[0].id;

        // 2. Verify assignment and get current thesis version
        const thesisSql = `
            SELECT t.version
            FROM examiner_assignments ea
            JOIN thesis t ON ea.thesis_id = t.id
            WHERE ea.examiner_id = ?
                AND t.id = ?
                AND t.status = 'Under_Examination'
                AND t.is_locked = FALSE
        `;
        const [thesisRows] = await connection.query(thesisSql, [examiner_id, thesis_id]);
        
        if (thesisRows.length === 0) {
            return res.status(403).json({ message: "Not authorized or thesis not ready for evaluation" });
        }
        const version = thesisRows[0].version;

        // START TRANSACTION [cite: 313]
        await connection.beginTransaction();

        // 3. Prevent duplicate evaluation PER VERSION
        const checkSql = `
            SELECT id FROM examiner_grades
            WHERE thesis_id = ?
              AND examiner_id = ?
              AND thesis_version = ?
        `;
        const [existingGrades] = await connection.query(checkSql, [thesis_id, examiner_id, version]);
        
        if (existingGrades.length > 0) {
            await connection.rollback(); 
            return res.status(409).json({ message: "Already evaluated for this version" });
        }

        // 4. Insert grade [cite: 317]
        const insertSql = `
            INSERT INTO examiner_grades
            (thesis_id, examiner_id, thesis_version, grade, remarks)
            VALUES (?, ?, ?, ?, ?)
        `;
        await connection.query(insertSql, [thesis_id, examiner_id, version, grade, remarks]);

        // 5. CHECK if 2 examiners finished evaluation for this specific version
        const readySql = `
            SELECT COUNT(DISTINCT examiner_id) as total
            FROM examiner_grades
            WHERE thesis_id = ?
            AND thesis_version = ?
        `;
        const [countRows] = await connection.query(readySql, [thesis_id, version]);

        if (countRows[0].total >= 2) {
            const updateReady = `
                UPDATE thesis
                SET ready_for_final = TRUE
                WHERE id = ?
            `;
            await connection.query(updateReady, [thesis_id]);
        }

        await connection.commit();
        res.json({ message: "Evaluation submitted successfully" });

    } catch (err) {
        await connection.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error during evaluation" });
    } finally {
        connection.release();
    }
};




this is studentController.js:
const db = require('../config/db');
const { deleteFile } = require('../middleware/fileDelete');
// const deleteFile = requier('../middleware/fileDelete.js')

// helper query for student id
const stdsql = 'SELECT id FROM students WHERE user_id = ?';

// --- PROPOSALS ---

// 1. Submit Proposals
exports.submitProposal = async (req, res) => {
    const connection = await db.promise().getConnection();

    // eep trac of file path to clean up
    const filePathToDelete = req.file ? 'uploads/proposals/' + req.file.filename : null;
    try {
        const user_id = req.user.id;
        const { title } = req.body;

        if (!req.file) return res.status(400).json({ message: "Proposal file is required" });
        if (!title) {
            deleteFile(filePathToDelete); // Delete if title is missing
            return res.status(409).json({ message: "Title is required" });

        } 

        const file_path = 'uploads/proposals/' + req.file.filename;

        // Get student id
        const [students] = await connection.query(stdsql, [user_id]);
        if (students.length === 0) {
            deleteFile(filePathToDelete); // Delete if not a student
            return res.status(409).json({ message: "Not a Student" });
        }
        const student_id = students[0].id;

        // Check for existing pending proposal
        const checkppsql = `SELECT id FROM proposals WHERE student_id = ? AND status = 'pending'`;
        const [pending] = await connection.query(checkppsql, [student_id]);

        if (pending.length > 0) {
            deleteFile(filePathToDelete); // Delete if they already have a pending one
            return res.status(409).json({ message: "You already have a pending proposal. Wait for decision first." });
        }

        // Insert new proposal
        const insertsql = `INSERT INTO proposals (student_id, title, file_path) VALUES(?, ?, ?)`;
        const [result] = await connection.query(insertsql, [student_id, title, file_path]);

        res.status(201).json({
            message: "Proposal Submitted Successfully",
            proposal_id: result.insertId
        });
    } catch (err) {
        console.error(err);
        deleteFile(filePathToDelete); // IMPORTANT: Delete if DB crashes
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. List Proposals
exports.getMyProposals = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(409).json({ message: "Not a Student" });

        const sql = `
            SELECT id, title, status, submitted_at 
            FROM proposals 
            WHERE student_id = ? 
            ORDER BY submitted_at DESC`;
        const [rows] = await connection.query(sql, [students[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 3. View Proposal Status (with Latest Approval)
exports.getMyProposalStatus = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(403).json({ message: "Not a student" });

        const sql = `
            SELECT p.id AS proposal_id, p.title, p.status, p.submitted_at,
                   a.status AS decision_status, a.remarks, a.approved_at
            FROM proposals p
            LEFT JOIN approvals a ON a.reference_type = 'proposal' AND a.reference_id = p.id
            AND a.id = (SELECT MAX(id) FROM approvals WHERE reference_type = 'proposal' AND reference_id = p.id)
            WHERE p.student_id = ?
            ORDER BY p.submitted_at DESC`;

        const [rows] = await connection.query(sql, [students[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- PROGRESS REPORT ---

// 1. Submit Progress Report
exports.submitProgressReport = async (req, res) => {
    const connection = await db.promise().getConnection();
    const filePathToDelete = req.file ? 'uploads/progress_reports/' + req.file.filename : null;

    try {
        const { semester } = req.body;
        if (!req.file) return res.status(400).json({ message: "Progress report file is required" });
        if (!semester) {
            deleteFile(filePathToDelete);
            return res.status(400).json({ message: "Semester is Missing" });
        } 

        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) {
            deleteFile(filePathToDelete);
            return res.status(403).json({ message: "Not a Student" });
        }
        
        const student_id = students[0].id;
        const file_path = 'uploads/progress_reports/' + req.file.filename;

        // Check if already submitted and not rejected
        const checksql = `SELECT id FROM progress_reports WHERE student_id = ? AND semester = ? AND status != 'Rejected'`;
        const [existing] = await connection.query(checksql, [student_id, semester]);

        if (existing.length > 0) {
            deleteFile(filePathToDelete);
            return res.status(409).json({ message: "Report for this semester already exists. Wait for decision." });
        }

        const insertsql = `INSERT INTO progress_reports (student_id, semester, file_path) VALUES (?, ?, ?)`;
        const [result] = await connection.query(insertsql, [student_id, semester, file_path]);

        res.status(201).json({ message: "Progress Report Submitted Successfully", report_id: result.insertId });
    } catch (err) {
        console.error(err);
        deleteFile(filePathToDelete);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. List Progress Reports
exports.getMyProgressReport = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(403).json({ message: "Not a Student" });

        const sql = `SELECT id, semester, status, submitted_at FROM progress_reports WHERE student_id = ? ORDER BY submitted_at DESC`;
        const [rows] = await connection.query(sql, [students[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- PUBLICATIONS ---

// 1. Add Publication
exports.addPublication = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const { title, journal_name, year, type } = req.body;
        if (!title || !year || !type) return res.status(400).json({ message: "Title, year and type are required" });
        if (!['Journal', 'Conference'].includes(type)) return res.status(400).json({ message: "Type must be Conference or Journal" });

        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(403).json({ message: "Not a student" });

        const insertsql = `INSERT INTO publications (student_id, title, journal_name, year, type) VALUES (?, ?, ?, ?, ?)`;
        const [result] = await connection.query(insertsql, [students[0].id, title, journal_name || null, year, type]);

        res.status(201).json({ message: "Publication added successfully", publication_id: result.insertId });
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. List My Publications
exports.getMypublication = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(403).json({ message: "Not a student" });

        const sql = `SELECT id, title, journal_name, year, type FROM publications WHERE student_id = ? ORDER BY year DESC`;
        const [rows] = await connection.query(sql, [students[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- THESIS ---

// 1. Submit Thesis
exports.submitThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    const filePathToDelete = req.file ? 'uploads/thesis/' + req.file.filename : null;

    try {
        const { title } = req.body;
        if (!title || !req.file) {
            deleteFile(filePathToDelete);
            return res.status(400).json({ message: "Title and File are required" });
        }

        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0){
            deleteFile(filePathToDelete);
            return res.status(403).json({ message: "Not a student" });
        }

        const student_id = students[0].id;
        const [existing] = await connection.query(`SELECT id FROM thesis WHERE student_id = ?`, [student_id]);
        if (existing.length > 0){
            deleteFile(filePathToDelete);
            return res.status(409).json({ message: "Thesis already submitted" });
        }

        const file_path = 'uploads/thesis/' + req.file.filename;
        const insertsql = `INSERT INTO thesis (student_id, title, file_path) VALUES (?, ?, ?)`;
        const [result] = await connection.query(insertsql, [student_id, title, file_path]);

        res.status(201).json({ message: "Thesis submitted successfully", thesis_id: result.insertId });
    } catch (err) {
        console.error(err);
        deleteFile(filePathToDelete);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. List Thesis
exports.getMyThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) return res.status(403).json({ message: "Not a student" });

        const sql = `
            SELECT t.id, t.title, t.file_path, t.status, t.version,
                   a.status AS decision_status, a.remarks, a.approval_role, a.approved_at
            FROM thesis t
            LEFT JOIN approvals a ON a.id = (
                SELECT id FROM approvals WHERE reference_type = 'thesis' AND reference_id = t.id 
                AND thesis_version = t.version ORDER BY id DESC LIMIT 1
            )
            WHERE t.student_id = ?`;

        const [rows] = await connection.query(sql, [students[0].id]);
        res.json(rows.length ? rows[0] : null);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 3. Resubmit Thesis
exports.resubmitThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    const filePathToDelete = req.file ? 'uploads/thesis/' + req.file.filename : null;

    try {
        if (!req.file) return res.status(400).json({ message: "Thesis file is required" });

        const [students] = await connection.query(stdsql, [req.user.id]);
        if (students.length === 0) {
            deleteFile(filePathToDelete);
            return res.status(403).json({ message: "Not a student" });
        }

        const student_id = students[0].id;
        const [rows] = await connection.query(`SELECT id, status, version, is_locked FROM thesis WHERE student_id = ?`, [student_id]);

        if (rows.length === 0) {
            deleteFile(filePathToDelete);
            return res.status(404).json({ message: "Thesis not found" });
        } 
        const thesis = rows[0];

        if (thesis.status !== 'Rejected' || thesis.is_locked) {
            deleteFile(filePathToDelete);
            return res.status(403).json({ message: "Thesis is locked or not in rejected state." });
        }

        const file_path = 'uploads/thesis/' + req.file.filename;
        const newVersion = thesis.version + 1;

        await connection.query(
            `UPDATE thesis SET file_path = ?, version = ?, status = 'Pending', ready_for_final = FALSE WHERE id = ?`,
            [file_path, newVersion, thesis.id]
        );

        await connection.query(`DELETE FROM examiner_assignments WHERE thesis_id = ?`, [thesis.id]);

        res.json({ message: "Thesis Resubmitted successfully", new_version: newVersion });
    } catch (err) {
        console.error(err);
        deleteFile(filePathToDelete);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};




this is supervisor.js:
const db = require('../config/db');

// helper query to get supervisor id from user_id
const supsql = `SELECT id FROM supervisors WHERE user_id = ?`;

// --- PROPOSALS ---

// 1. Get my student proposals
exports.getMyStudentProposals = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a Supervisor" });

        const supervisor_id = supervisors[0].id;
        const sql = `
            SELECT p.id AS proposal_id, p.title, p.file_path, p.status, p.submitted_at,
                   s.id AS student_id, CONCAT(u.first_name,' ', u.last_name) AS student_name, s.registration_no
            FROM proposals p
            JOIN students s ON p.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.supervisor_id = ?
            ORDER BY p.status ASC, p.submitted_at DESC`;

        const [rows] = await connection.query(sql, [supervisor_id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. Approve / Reject proposal
exports.decideProposal = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const { status, remarks } = req.body;
        const proposal_id = req.params.id;

        if (!status || !['Approved', 'Rejected'].includes(status)) {
            return res.status(400).json({ message: "Status must be Approved or Rejected" });
        }

        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const supervisor_id = supervisors[0].id;

        // Check ownership and status
        const [rows] = await connection.query(
            `SELECT p.id FROM proposals p JOIN students s ON p.student_id = s.id 
             WHERE p.id = ? AND s.supervisor_id = ? AND p.status = 'Pending'`,
            [proposal_id, supervisor_id]
        );

        if (rows.length === 0) return res.status(404).json({ message: "Proposal not found or already decided" });

        await connection.beginTransaction();

        await connection.query(`UPDATE proposals SET status = ? WHERE id = ?`, [status, proposal_id]);

        const insertsql = `INSERT INTO approvals (reference_type, reference_id, approval_role, approved_by, status, remarks)
                           VALUES (?, ?, ?, ?, ?, ?)`;
        await connection.query(insertsql, ['proposal', proposal_id, 'Supervisor', req.user.id, status, remarks || null]);

        await connection.commit();
        res.json({ message: `Proposal ${status} successfully` });
    } catch (err) {
        await connection.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- PROGRESS REPORTS ---

// 1. Get my student progress reports
exports.getStudentProgressReports = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const sql = `
            SELECT pr.id AS report_id, pr.semester, pr.file_path, pr.status, pr.submitted_at,
                   s.registration_no, CONCAT(u.first_name, ' ', u.last_name) AS student_name
            FROM progress_reports pr
            JOIN students s ON pr.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.supervisor_id = ?
            ORDER BY pr.status ASC, pr.submitted_at DESC`;

        const [rows] = await connection.query(sql, [supervisors[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// 2. Approve / Reject Progress Reports
exports.decideProgressReport = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const { status, remarks } = req.body;
        const report_id = req.params.id;

        if (!status || !['Approved', 'Rejected'].includes(status)) {
            return res.status(400).json({ message: "Status must be Approved or Rejected" });
        }

        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const [rows] = await connection.query(
            `SELECT pr.id FROM progress_reports pr JOIN students s ON pr.student_id = s.id 
             WHERE pr.id = ? AND s.supervisor_id = ? AND pr.status = 'Pending'`,
            [report_id, supervisors[0].id]
        );

        if (rows.length === 0) return res.status(404).json({ message: "Report not found or already decided" });

        await connection.beginTransaction();

        await connection.query(`UPDATE progress_reports SET status = ? WHERE id = ?`, [status, report_id]);

        const insertsql = `INSERT INTO approvals (reference_type, reference_id, approval_role, approved_by, status, remarks)
                           VALUES (?, ?, ?, ?, ?, ?)`;
        await connection.query(insertsql, ['report', report_id, 'Supervisor', req.user.id, status, remarks || null]);

        await connection.commit();
        res.json({ message: `Progress Report ${status} successfully` });
    } catch (err) {
        await connection.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- PUBLICATIONS ---

exports.getMyStudentPublications = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const sql = `
            SELECT p.id AS publication_id, p.title, p.journal_name, p.year, p.type,
                   s.registration_no, CONCAT(u.first_name,' ',u.last_name) AS student_name
            FROM publications p
            JOIN students s ON p.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.supervisor_id = ?
            ORDER BY p.year DESC`;

        const [rows] = await connection.query(sql, [supervisors[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

// --- THESIS ---

exports.getMyStudentThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const sql = `
            SELECT t.id AS thesis_id, t.title, t.file_path, t.status, t.submitted_at,
                   s.id AS student_id, s.registration_no, CONCAT(u.first_name,' ',u.last_name) AS student_name
            FROM thesis t
            JOIN students s ON t.student_id = s.id
            JOIN users u ON s.user_id = u.id
            WHERE s.supervisor_id = ?
            ORDER BY t.status`;

        const [rows] = await connection.query(sql, [supervisors[0].id]);
        res.json(rows);
    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};

exports.decideThesis = async (req, res) => {
    const connection = await db.promise().getConnection();
    try {
        const { status, remarks } = req.body;
        const thesis_id = req.params.id;

        if (!status || !['Approved', 'Rejected'].includes(status)) {
            return res.status(400).json({ message: "Status must be Approved or Rejected" });
        }

        const [supervisors] = await connection.query(supsql, [req.user.id]);
        if (supervisors.length === 0) return res.status(403).json({ message: "Not a supervisor" });

        const [rows] = await connection.query(
            `SELECT t.id, t.version FROM thesis t JOIN students s ON t.student_id = s.id
             WHERE t.id = ? AND s.supervisor_id = ? AND t.status = 'Pending' AND t.is_locked = FALSE`,
            [thesis_id, supervisors[0].id]
        );

        if (rows.length === 0) return res.status(404).json({ message: "Thesis not found or already decided" });

        const version = rows[0].version;

        await connection.beginTransaction();

        await connection.query(`UPDATE thesis SET status = ? WHERE id = ?`, [status, thesis_id]);

        const insertsql = `INSERT INTO approvals (reference_type, reference_id, approval_role, approved_by, status, remarks, thesis_version)
                           VALUES (?, ?, ?, ?, ?, ?, ?)`;
        await connection.query(insertsql, ['thesis', thesis_id, 'Supervisor', req.user.id, status, remarks || null, version]);

        await connection.commit();
        res.json({ message: `Thesis ${status} successfully` });
    } catch (err) {
        await connection.rollback();
        console.error(err);
        res.status(500).json({ message: "Server Error" });
    } finally {
        connection.release();
    }
};